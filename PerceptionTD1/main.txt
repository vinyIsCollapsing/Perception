
#include <opencv4/opencv2/core.hpp>
#include <opencv4/opencv2/highgui.hpp>
#include <opencv4/opencv2/imgcodecs/imgcodecs.hpp>
#include <opencv4/opencv2/imgproc.hpp>
#include <iostream>

using namespace cv;
using namespace std;

// Variables
Mat image, resized_image, mask, roiImage;
double scale = 0.2;
Rect roi;
bool selecting = false;
Scalar Mean, stddev;

// Function declarations
void display_image(); 
void RGB_mouse(int event, int x, int y, int flags, void* userdata); 
Mat bgr_to_gray_luma(Mat &image); 
void area_mouse(int event, int x, int y, int flags, void* userdata); 
void CalculateMeanStdDev(Mat &roi); 
Mat drawRec(const string& imagePath); 
Mat makeMask(Mat &hsv_image, Scalar Mean, Scalar stddev, double alpha); 
void findCentroid(Mat &mask, Mat &copy_image); 
void SaveReferenceFrames(const string& videoPath);

int main() {
    image = imread("balle.jpg"); // Load image
    if (image.empty()) {
        cerr << "Could not read the image." << endl;
        return -1;
    }

    namedWindow("Balle", WINDOW_AUTOSIZE); // Create window

    // Uncomment to test different exercises

    //Exercise 1: RGB Click
    // setMouseCallback("Balle", RGB_mouse, &resized_image);
    // display_image();
    // waitKey(0);

    // Exercise 2: Monochrome
    // cvtColor(image, image, COLOR_BGR2GRAY);
    // image = bgr_to_gray_luma(image);
    // display_image();
    // waitKey(0);

    // Exercise 3: Mean and StdDev of selected area
    // setMouseCallback("Balle", area_mouse, &resized_image);
    // display_image();
    // drawRec(resized_image);
    // roiImage = resized_image(roi);
    // meanStdDev(roiImage, Mean, stddev);
    // cout << "Mean - R: " << Mean[2] << ", G: " << Mean[1] << ", B: " << Mean[0] << endl;
    // cout << "StdDev - R: " << stddev[2] << ", G: " << stddev[1] << ", B: " << stddev[0] << endl;
    // waitKey(0);

    // Exercise 4: Color similar pixels red
    // setMouseCallback("Balle", area_mouse, &resized_image);
    // display_image();
    // drawRec(resized_image);
    // roiImage = resized_image(roi);
    // meanStdDev(roiImage, Mean, stddev);
    // for (int j = 0; j < resized_image.rows; j++) {
    //     for (int i = 0; i < resized_image.cols; i++) {
    //         Vec3b pixel = resized_image.at<Vec3b>(j, i);
    //         if (abs(pixel[0] - Mean[0]) <= stddev[0] && abs(pixel[1] - Mean[1]) <= stddev[1] && abs(pixel[2] - Mean[2]) <= stddev[2]) {
    //             resized_image.at<Vec3b>(j, i) = Vec3b(0, 0, 255); // Set to red
    //         }
    //     }
    // }
    // imshow("RED selection", resized_image);
    // waitKey(0);

    // Exercise 5: HSV and Mask
    // Mat hsv_image;
    // setMouseCallback("Balle", area_mouse, &resized_image);
    // display_image();
    // drawRec(resized_image);
    // cvtColor(resized_image, hsv_image, COLOR_BGR2HSV);
    // roiImage = hsv_image(roi);
    // meanStdDev(roiImage, Mean, stddev);
    // mask = makeMask(hsv_image, Mean, stddev, 5);
    // Mat copy_image = resized_image.clone();
    // copy_image.setTo(Scalar(0, 0, 255), mask);
    // imshow("Balle", copy_image);
    // waitKey(0);

    // Exercise 6: Centroid of tracked object
    // setMouseCallback("Balle", area_mouse, &resized_image);
    // display_image();
    // drawRec(resized_image);
    // cvtColor(resized_image, hsv_image, COLOR_BGR2HSV);
    // roiImage = hsv_image(roi);
    // meanStdDev(roiImage, Mean, stddev);
    // mask = makeMask(hsv_image, Mean, stddev, 5);
    // Mat copy_image = resized_image.clone();
    // copy_image.setTo(Scalar(0, 0, 255), mask);
    // findCentroid(mask, copy_image);
    // imshow("Balle", copy_image);
    // waitKey(0);
    
    destroyWindow("Balle");
    return 0;
}

// Function definitions
void display_image() {
    resize(image, resized_image, Size(), scale, scale, INTER_LINEAR);
    imshow("Balle", resized_image);
}

void RGB_mouse(int event, int x, int y, int flags, void* userdata) {
    if (event == EVENT_LBUTTONDOWN) {
        Mat* image = static_cast<Mat*>(userdata);
        Vec3b bgrPixel = image->at<Vec3b>(y, x);
        cout << "R: " << (int)bgrPixel[2] << ", G: " << (int)bgrPixel[1] << ", B: " << (int)bgrPixel[0] << endl;
        cout << "X: " << x << ", Y: " << y << endl;
    }
}

Mat bgr_to_gray_luma(Mat &image) {
    Mat monoimage(image.size(), CV_8UC1);
    for (int j = 0; j < image.rows; j++) {
        for (int i = 0; i < image.cols; i++) {
            Vec3b bgrPixel = image.at<Vec3b>(j, i);
            uchar gray = static_cast<uchar>(bgrPixel[2]*0.2989 + bgrPixel[1]*0.587 + bgrPixel[0]*0.114);
            monoimage.at<uchar>(j, i) = gray;
        }
    }
    return monoimage;
}

void area_mouse(int event, int x, int y, int flags, void* userdata) {
    if (event == EVENT_LBUTTONDOWN) {
        roi = Rect(x, y, 0, 0);
        selecting = true;
    } else if (event == EVENT_MOUSEMOVE) {
        if (selecting) {
            roi.width = x - roi.x;
            roi.height = y - roi.y;
        }
    } else if (event == EVENT_LBUTTONUP) {
        selecting = false;
        if (roi.width < 0) {
            roi.x += roi.width;
            roi.width = -roi.width;
        }
        if (roi.height < 0) {
            roi.y += roi.height;
            roi.height = -roi.height;
        }
    }
}

Mat drawRec(const string& imagePath) {
    Mat Image = imread(imagePath);
    if (Image.empty()) {
        cerr << "Could not read the image." << endl;
        return Mat();
    }
    Mat resizedImage;
    resize(Image, resizedImage, Size(), 0.5, 0.5, INTER_LINEAR);
    namedWindow("Select", WINDOW_AUTOSIZE);
    setMouseCallback("Select", area_mouse, &resizedImage);
    while (true) {
        Mat copyImage = resizedImage.clone();
        if (selecting) rectangle(copyImage, roi, Scalar(255, 0, 0), 1);
        imshow("Select", copyImage);
        if (waitKey(30) != -1) break;
    }
    Mat selectedArea = resizedImage(roi);
    destroyWindow("Select");
    return selectedArea;
}

Mat makeMask(Mat &hsv_image, Scalar Mean, Scalar stddev, double alpha) {
    Scalar lower_bound = Mean - alpha*stddev;
    Scalar upper_bound = Mean + alpha*stddev;
    inRange(hsv_image, lower_bound, upper_bound, mask);
    return mask;
}

void findCentroid(Mat &mask, Mat &copy_image) {
    Moments M = moments(mask);
    int cx = static_cast<int>(M.m10 / M.m00);
    int cy = static_cast<int>(M.m01 / M.m00);
    line(copy_image, Point(cx - 10, cy), Point(cx + 10, cy), Scalar(255, 255, 0), 2);
    line(copy_image, Point(cx, cy - 10), Point(cx, cy + 10), Scalar(255, 255, 0), 2);
}

void SaveReferenceFrames(const string& videoPath) {
    VideoCapture cap(videoPath); // Open video file
    if (!cap.isOpened()) {
        cerr << "Error: Could not open video." << endl;
        return;
    }

    int totalFrames = static_cast<int>(cap.get(CAP_PROP_FRAME_COUNT));
    if (totalFrames <= 0) {
        cerr << "Error: Could not retrieve total number of frames." << endl;
        return;
    }

    // Define frame positions to capture
    int beginFrame = 0;
    int middleFrame = totalFrames / 2;
    int endFrame = totalFrames - 1;
    int framesToCapture[3] = {beginFrame, middleFrame, endFrame};

    // Loop through and save each frame
    for (int i = 0; i < 3; i++) {
        cap.set(CAP_PROP_POS_FRAMES, framesToCapture[i]);
        Mat frame;
        bool success = cap.read(frame);
        if (success) {
            string filename = "frame_" + to_string(framesToCapture[i]) + ".jpg";
            imwrite(filename, frame); // Save frame as an image
        } else {
            cerr << "Error: Could not read frame at position " << framesToCapture[i] << endl;
        }
    }

    cap.release(); // Release the video capture object
}